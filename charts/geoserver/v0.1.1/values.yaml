image:
  registry: docker.io
  repository: kartoza/geoserver
  tag: "2.16.2"
  pullPolicy: IfNotPresent

geoserverDataDir: /opt/geoserver/data_dir
geowebcacheCacheDir: /opt/geoserver/data_dir/gwc

service:
  ## PosgresSQL service type
  type: ClusterIP
  clusterIP: ""
  # externalIPs: ""
  port: 80

  # nodePort:

  annotations: {}

  # loadBalancerIP:

  # loadBalancerSourceRanges:
  # - 10.10.10.0/24
persistence:
  geoserverDataDir:
    enabled: true
    existingClaim: false
    mountPath: /opt/geoserver/data_dir
    subPath: ""
    size: 8Gi
    accessModes:
      - ReadWriteOnce
    annotations: {}
  geowebcacheCacheDir:
    enabled: true
    existingClaim: false
    mountPath: /opt/geoserver/data_dir/gwc
    subPath: ""
    size: 8Gi
    accessModes:
      - ReadWriteOnce
    annotations: {}

networkPolicy:
  ## Enable creation of NetworkPolicy resources. Only Ingress traffic is filtered for now.
  ##
  enabled: false

  ## The Policy model to apply. When set to false, only pods with the correct
  ## client label will have network access to the port PostgreSQL is listening
  ## on. When true, PostgreSQL will accept connections from any source
  ## (with the correct destination port).
  ##
  allowExternal: true

  ## if explicitNamespacesSelector is missing or set to {}, only client Pods that are in the networkPolicy's namespace
  ## and that match other criteria, the ones that have the good label, can reach the DB.
  ## But sometimes, we want the DB to be accessible to clients from other namespaces, in this case, we can use this
  ## LabelSelector to select these namespaces, note that the networkPolicy's namespace should also be explicitly added.
  ##
  ## Example:
  ## explicitNamespacesSelector:
  ##   matchLabels:
  ##     role: frontend
  ##   matchExpressions:
  ##    - {key: role, operator: In, values: [frontend]}
  explicitNamespacesSelector: {}
