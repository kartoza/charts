# Postgis

This is Kartoza's Postgis Rancher charts

Postgis is an extension of PostgreSQL database with added support for Spatial Data

# How to Use

For helm:

```bash
helm install release-name kartoza/postgis
```

# Intro

This chart bootstrap a PostgreSQL database with Postgis installed in its main database.
It behaves like a PostgreSQL database, but with Postgis extension installed in its database.

# What it can do

The default install uses kartoza/postgis image, which can do the following:

- Generate superuser roles at startup
- Generate new database at startup if volume empty
- Generate one or more database with Postgis installed
- Accept locale and collations settings for the database
- Default TLS enabled
- GDAL Driver installed
- Support out-of-db rasters
- Enable multiple extensions

# Parameters

| Parameter | Description |
|---|---|
| image.registry | Docker image registry |
| image.repository | Docker image repository |
| image.tag | Docker image tag |
| image.pullPolicy | Docker image pull policy |
| postgresqlUsername | PostgreSQL superuser name |
| postgresqlPassword | PostgreSQL superuser password. If leave empty, it will be autogenerated every update. |
| postgresqlDatabase | Default main PostgreSQL database |
| postgresqlDataDir | Location in the pods of where the PostgreSQL Data Directory is |
| existingSecret | [tpl string] Provide secret name or tpl expression for where the secret is |
| extraPodEnv | [tpl string] Provide extra environment that will be passed into pods. Useful for non default image. |
| extraSecret | [tpl string] Provide extra secret that will be included in the pods. Useful for non default image. |
| extraConfigMap: | [tpl string] Provide extra config map that will be included in the pods. Useful for non default image. |
| extraVolumeMounts | [tpl string] Provide extra volume mounts declaration that will be included in the pods. Useful if you want to mount extra things. |
| extraVolume | [tpl string] Configuration pair with extraVolumeMounts. Declare which volume to mount in the pods. |
| persistence.enabled | Default to true. If set, it will make a volume claim |
| persistence.existingClaim | Default to false. If set, it will use an existing claim name provided |
| persistence.mountPath | The path where the volume will be in the pods |
| persistence.subPath | The path inside the the volume to mount to. Useful if you want to reuse the same volume but mount the subpath for different services. |
| persistence.size | Size of the volume to store PostgreSQL Data Dir |
| persistence.accessModes | Access mode of the volume. Normally ReadWriteOnce because PostgreSQL is stateful |
| service.type | The type of kubernetes service to be created. Leave it be for Headless service |
| service.loadBalancerIP | Only used if you use LoadBalancer service.type |
| service.externalIPs | External IPs to use for the service |
| service.port | External port to use/expose |
| tls.enabled | Our docker image always use TLS even if you set it to false (default certificate). If you set it to true, that means you want to use your certificate. |
| tls.secretName | The secret location of type kubernetes.io/tls (certificate) where your certificate is located. |
| tls.ca_file | The data key of the CA certificate in your secret. Usually called ca.crt |
| tls.cert_file | The data key of the certificate itself in your secret. Usually called tls.crt |
| tls.key_file | The data key for the private key of the certificate in your secret. Usually called tls.key |
| probe | An override options for pod probe/health check |

# Common use case

## Using it as a headless service

By default, we created a Headless service. Headless service can only be accessed within the cluster itself. 
The name of the service can be used as the hostname. If you need to expose this, you can further cascade it using LoadBalancer or NodePort.

## Using custom certificate in conjunction with cert-manager.io

With cert-manager you can automatically create certificate. First, you need an issuer and also the certificate request object.
Cert-manager will then create the certificate and store it into a secret. This should happen before you create the Postgis App.

 Use the generated secret by filling out `tls` config options. 
 Because Postgres works in L3/4 Layer, the generated CA must be accepted by your OS if you want to connect using self-signed certificate.
 If not, then you can just ignore the warning. However some Database client will check the CA, depending on what is the mode of the connection,
 which can be: disable, allow, required, verify-ca, verify-full.

## Executing scripts after the database starts

Sometimes you want to execute certain scripts after the database is ready. Our default image can do that (and most Postgres image based on official Postgres).

The best way would be to create a ConfigMap with your scripts in it, then apply it to your Kubernetes Cluster.
Reference: https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap

Then mount it to the pod using our `extraVolume` and `extraVolumeMounts` config. If you mount it in the pod's path: `/docker-entrypoint-initdb.d/` , it will be scanned by the image.
The executed scripts are only files with the extensions `.sql` and `.sh`.

Depending on the postgres image you use, you can also mount it to directory where the entrypoint script will be executed according to that image implementations.


## Replications

TODO: Describe how replication works with stateful set pods.
